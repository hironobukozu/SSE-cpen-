#include <cpen333/process/subprocess.h>
#include <cpen333/process/shared_memory.h>
#include <chrono>
#include <thread>
#include <string>
#include <iostream>
#include <mutex>

struct SharedData {
	int count;
	bool trigger[2] = {};
};

void increment(const std::string& name, int index, std::mutex& mutex) {
	cpen333::process::shared_memory memory("malware", sizeof(SharedData));
	SharedData *data = (SharedData*)memory.get();
	mutex.lock();
	data->count++;
	mutex.unlock();

}

bool check(int n, int count, int oindex) {
	if (n == count) {
		return false;
	}
	return true;
}

void restart(int oindex) {
	std::vector<std::string> cmd1;
	cmd1.push_back("malware");
	cmd1.push_back("malware");
	cmd1.push_back(std::to_string(oindex));
	cpen333::process::subprocess process1(cmd1, true, true);
}

// Usage:
//    malware <name> <index>
// name is any name
// index is 0 or 1
// defaults to name:malware, index:0
int main(int argc, char* argv[]) {

	// extract name and index
	int index = 0;
	std::string name = "malware";
	if (argc > 1) {
		name = argv[1];
	}
	if (argc > 2) {
		index = std::atoi(argv[2]);
	}

	std::cout << name << " " << std::to_string(index) << " started" << std::endl;
	std::mutex mutex;
	//========================================================
	// TODO: CREATE AND INITIALIZE SHARED MEMORY
	//========================================================
	cpen333::process::shared_memory memory("malware", sizeof(SharedData));
	SharedData *data = (SharedData*)memory.get();
	data->count = 0;


	int oindex = (index + 1) % 2;  // index of other malware process

	int n = data->count;
	while (true) {
		std::cout << name << " " << std::to_string(index) << " running" << std::endl;
		std::this_thread::sleep_for(std::chrono::seconds(3));

		mutex.lock();
		data -> trigger[oindex] = check(n, data->count, oindex);
		mutex.unlock();
		increment(std::ref(name), oindex, std::ref(mutex));
		if (data -> trigger[oindex] == false){
			restart(oindex);
			data -> trigger[oindex] = true;
		}
	n = data -> count;


    //=======================================================
    // TODO: CHECK IF OTHER PROCESS MISSED CHECK-IN(S)
    //       - LAUNCH IF NOT RESPONDING
    //=======================================================

  }

  if (data -> trigger[index] == false){
		  std::vector<std::string> cmd;
		  cmd.push_back("malware");
		  cmd.push_back("malware");
		  cmd.push_back(std::to_string(index));
		  data->trigger[index] = true;
		}

  return 0;
}


// create 2 PROCESSES
// create some kind of variable that each one updates
// check if the other has updated the variable
// if it has keep going
// if it hasnt, restart the other oindex
// if both go down it ends
